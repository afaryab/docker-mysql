name: Build and Release Docker Image

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Version bump type'
        required: true
        default: 'patch'
        type: choice
        options:
        - patch
        - minor
        - major

env:
  REGISTRY: docker.io
  IMAGE_NAME: ahmadfaryabkokab/mysql8

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Create test backup directory
      run: mkdir -p test-backups

    - name: Run comprehensive tests
      run: |
        # Build the test image
        docker build -t ahmadfaryabkokab/mysql8:test .
        
        # Start services
        docker compose -f docker-compose.test.yml up -d
        
        # Wait for MySQL to be ready
        echo "Waiting for MySQL to start..."
        for i in {1..60}; do
          if docker compose -f docker-compose.test.yml exec -T mysql mysqladmin ping -h localhost -u root -ptestpass123 --silent 2>/dev/null; then
            echo "MySQL is ready!"
            # Additional wait to ensure MySQL is fully initialized
            sleep 5
            break
          fi
          echo "Waiting... ($i/60)"
          sleep 3
        done
        
        # Verify MySQL is truly ready by testing a simple query
        echo "Verifying MySQL connection..."
        docker compose -f docker-compose.test.yml exec -T mysql mysql -uroot -ptestpass123 -e "SELECT 1;" || {
          echo "MySQL connection failed, checking logs..."
          docker compose -f docker-compose.test.yml logs mysql
          exit 1
        }

        # Test basic functionality
        docker compose -f docker-compose.test.yml exec -T mysql mysql -uroot -ptestpass123 -e "
          CREATE DATABASE IF NOT EXISTS testdb;
          USE testdb; 
          CREATE TABLE test (id INT PRIMARY KEY, name VARCHAR(50)); 
          INSERT INTO test VALUES (1, 'test data');
          SELECT * FROM test;
        "
        
        # Test backup script
        docker compose -f docker-compose.test.yml exec -T mysql /usr/local/bin/backup.sh
        
        # Verify backup was created
        sleep 3
        if ls test-backups/mysql-*.sql.gz 1> /dev/null 2>&1; then
          echo "✅ Backup created successfully"
        else
          echo "❌ Backup creation failed"
          ls -la test-backups/
          exit 1
        fi
        
        # Test usage report
        docker compose -f docker-compose.test.yml exec -T mysql /usr/local/bin/usage_report.sh
        
        # Verify usage report was created
        if ls test-backups/usage/*.json 1> /dev/null 2>&1; then
          echo "✅ Usage report created successfully"
        else
          echo "❌ Usage report creation failed"
          ls -la test-backups/usage/ 2>/dev/null || echo "Usage directory not found"
          exit 1
        fi
        
        # Test auto-recovery by restarting
        echo "Testing auto-recovery..."
        docker compose -f docker-compose.test.yml down
        docker compose -f docker-compose.test.yml up -d
        
        # Wait for recovery
        for i in {1..90}; do
          if docker compose -f docker-compose.test.yml exec -T mysql mysqladmin ping -h localhost -u root -ptestpass123 --silent 2>/dev/null; then
            echo "Auto-recovery completed!"
            break
          fi
          echo "Waiting for recovery... ($i/90)"
          sleep 3
        done
        
        # Verify data exists after recovery
        RESULT=$(docker compose -f docker-compose.test.yml exec -T mysql mysql -uroot -ptestpass123 -e "USE testdb; SELECT COUNT(*) FROM test;" 2>/dev/null | tail -n1 | tr -d '\r')
        if [ "$RESULT" = "1" ]; then
          echo "✅ Auto-recovery successful"
        else
          echo "❌ Auto-recovery failed. Expected 1, got: '$RESULT'"
          docker compose -f docker-compose.test.yml logs mysql
          exit 1
        fi
        
        # Clean up
        docker compose -f docker-compose.test.yml down -v
        
        echo "🎉 All tests passed successfully!"

  version:
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: [test]  # Only run after tests pass
    outputs:
      new_version: ${{ steps.calculate_version.outputs.new_version }}
      release_created: ${{ steps.calculate_version.outputs.release_created }}
    permissions:
      contents: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Calculate next version
      id: calculate_version
      run: |
        # Get the latest tag
        latest_tag=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
        echo "Latest tag: $latest_tag"
        
        # Remove 'v' prefix if present
        current_version=${latest_tag#v}
        echo "Current version: $current_version"
        
        # Split version into components
        IFS='.' read -ra VERSION_PARTS <<< "$current_version"
        major=${VERSION_PARTS[0]:-0}
        minor=${VERSION_PARTS[1]:-0}
        patch=${VERSION_PARTS[2]:-0}
        
        echo "Current: $major.$minor.$patch"
        
        # Determine version bump type from commit messages or workflow input
        version_type="${{ github.event.inputs.version_type }}"
        
        if [ -z "$version_type" ]; then
          # Analyze commit messages since last tag
          commits=$(git log ${latest_tag}..HEAD --oneline 2>/dev/null || git log --oneline)
          
          if echo "$commits" | grep -i "BREAKING CHANGE\|major:" >/dev/null; then
            version_type="major"
          elif echo "$commits" | grep -i "feat\|feature\|minor:" >/dev/null; then
            version_type="minor"
          else
            version_type="patch"
          fi
        fi
        
        echo "Version bump type: $version_type"
        
        # Calculate new version
        case $version_type in
          major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
          minor)
            minor=$((minor + 1))
            patch=0
            ;;
          patch)
            patch=$((patch + 1))
            ;;
        esac
        
        new_version="$major.$minor.$patch"
        new_tag="v$new_version"
        
        echo "New version: $new_version"
        echo "New tag: $new_tag"
        
        # Check if there are changes since last tag
        if [ "$latest_tag" != "v0.0.0" ]; then
          changes=$(git log ${latest_tag}..HEAD --oneline)
          if [ -z "$changes" ]; then
            echo "No changes since last tag, skipping release"
            echo "release_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi
        fi
        
        # Set outputs
        echo "new_version=$new_version" >> $GITHUB_OUTPUT
        echo "release_created=true" >> $GITHUB_OUTPUT
        
        # Create and push tag
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "$new_tag" -m "Release $new_tag"
        git push origin "$new_tag"

  build:
    runs-on: ubuntu-latest
    needs: [test, version]  # Require both test and version to complete
    if: always() && needs.test.result == 'success' && (needs.version.outputs.release_created == 'true' || github.event_name == 'pull_request' || github.ref != 'refs/heads/main')
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=raw,value=${{ needs.version.outputs.new_version }},enable=${{ needs.version.outputs.release_created == 'true' }}
          type=raw,value=latest,enable=${{ needs.version.outputs.release_created == 'true' }}
          type=raw,value=dev,enable={{is_default_branch}}
          type=sha,prefix={{branch}}-

    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: ${{ github.event_name != 'pull_request' }}
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Generate artifact attestation
      if: github.event_name != 'pull_request' && github.repository_owner == 'afaryab'
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME}}
        subject-digest: ${{ steps.build.outputs.digest }}
        push-to-registry: true
      continue-on-error: true

  release:
    if: always() && needs.version.outputs.release_created == 'true' && needs.test.result == 'success'
    needs: [version, build, test]
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Generate release notes
      id: release_notes
      run: |
        # Get the previous tag
        previous_tag=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
        current_tag="v${{ needs.version.outputs.new_version }}"
        
        echo "Generating release notes from $previous_tag to $current_tag"
        
        # Create release notes
        {
          echo "## What's Changed"
          echo ""
          
          if [ -n "$previous_tag" ]; then
            # Get commits since last tag
            git log ${previous_tag}..HEAD --pretty=format:"* %s (%h)" --no-merges
          else
            # First release
            echo "* Initial release"
          fi
          
          echo ""
          echo ""
          echo "## Docker Images"
          echo ""
          echo "- \`docker pull ahmadfaryabkokab/mysql8:${{ needs.version.outputs.new_version }}\`"
          echo "- \`docker pull ahmadfaryabkokab/mysql8:latest\`"
          echo ""
          echo "## Features"
          echo ""
          echo "- 🔄 Automated MySQL backups with configurable schedules"
          echo "- 🚀 Auto-recovery from latest backup on fresh deployments"
          echo "- 🔐 Optional backup encryption with OpenSSL"
          echo "- 🧹 Automatic cleanup of old backups (configurable retention)"
          echo "- 📊 Usage reporting and monitoring"
          echo "- ⏰ Cron-based scheduling for all automated tasks"
          echo "- 🐳 Multi-architecture support (linux/amd64, linux/arm64)"
          
        } > release_notes.md
        
        echo "Release notes generated:"
        cat release_notes.md

    - name: Create Release
      uses: softprops/action-gh-release@v2
      with:
        tag_name: v${{ needs.version.outputs.new_version }}
        name: Release v${{ needs.version.outputs.new_version }}
        body_path: release_notes.md
        files: |
          README.md
          docker-compose.yml
          docker-compose.example.yml
          Dockerfile
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Update latest release info
      run: |
        echo "✅ Released version ${{ needs.version.outputs.new_version }}"
        echo "🐳 Docker images pushed:"
        echo "  - ahmadfaryabkokab/mysql8:${{ needs.version.outputs.new_version }}"
        echo "  - ahmadfaryabkokab/mysql8:latest"

  build-dev:
    if: github.event_name == 'push' && github.ref != 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [test]  # Require tests to pass before dev build
    permissions:
      contents: read
      packages: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}

    - name: Extract metadata for dev build
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=sha,prefix={{branch}}-

    - name: Build and push dev Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
